# Инструкция для решения задачи

## Задача:

Написать программу, которая из имеющегося массива строк формирует новый массив из строк, длина которых меньше, либо равна 3 символам. Первоначальный массив можно ввести с клавиатуры, либо задать на старте выполнения алгоритма. При решении не рекомендуется пользоваться коллекциями, лучше обойтись исключительно массивами.

## Решение.

Решение данной задачи можно разделить на несколько этапов:

1. Каким-то образом получить изначальный массив.

2. Посчитать в изначальном массиве количество строк, длина которых меньще, либо равна 3 - это будет длина нового массива.

3. Создать новый массив с найденной в п.2 длинной. Заполнить его подходящими строками из первого массива.

4. Распечать оба массива. 

Для поиска длины нового массива и метода, заполняющего его, составлена блок-схема:

![Блок-схема алгоритма](%D0%91%D0%BB%D0%BE%D0%BA-%D1%81%D1%85%D0%B5%D0%BC%D0%B0-1.jpg)

Получение изначального массива и распечатывание массивов в блок-схеме не описаны.


## Реализация.
___

**1. Получаем изначальный массив.**

Просим пользователя ввести изначальный массив _texts_ с клавиатуры. Длину массива задаем сами. 
___


**2. Считаем в изначальном массиве количество строк, длина которых меньше, либо равна 3.**

Для этого создаем метод _CountLenNewTexts_, который принимает массив и возвращает _count_ количество нужных строк. В методе задаем переменную-счетчик _count_ и циклом _for_ проходим по всему массиву _texts_. Если длина элемента меньше, либо равна 3, то увеличиваем счетчик _count_ на 1 и переходим к следующему элементу. Если нет, то просто переходим к следующему элементу.
___

**3. Создаем новый массив с найденной в п.2 длинной. Заполнить его подходящими строками из первого массива.**

Создаем метод _NewTexts_, который принимает массив и возвращает новый массив _newTexts_. В методе создаем 

* новую переменную _size_, в которую записываем результат выполнения метода _CountLenNewTexts_

* новый массив _newTexts_ с длинной _size_

* переменную _current_number_, которая будет счетчиком элементов нового массива 

Циклом _for_ проходим по всему массиву _texts_. Если длина элемента меньше, либо равна 3, то в _newTexts[current_number]_ записываем _texts[i]_. Увеличиваем счетчик _ccurrent_number_ на 1 и переходим к следующему элементу. Если нет, то просто переходим к следующему элементу.

Таким обрразом заполняем массив _newTexts_.
___

**4. Распечатываем оба массива.** Чтобы увидеть, что все получилось.

Здесь создем метод _PrintArray_, который принимает массив и распечатвает его в консоль.
Чтобы печать визуально выглядела, как в примере к Задаче, делаем в методе следующее:

* печатаем в консоль первую открывающую квадратную скобку ([ )

* создаем строковую переменную _gap_, которая будет содержать в себе просто ничего (""). Это "ничего" будет печататься после последнего элемента массива

* циклом _for_ идем по массиву и объединяем _gap_ и _array[i]_ с помощью _.ToString()_

* если текущей элемент массива плюс 1 не равен длинне массива (то есть элемент не последний), то заменяем _gap_ на (", "). 

* печатаем в консоль _gap_ 
* печатаем в консоль последнюю закрывающую кавычку и последнюю закрывающую квадратную скобочку ("])


___
___

_**Вот и все, ребята!**_






